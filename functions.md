# Документация функций TeleBlast

## Функции базы данных (database.py)

### delete_group(self, chat_id: int)
**Назначение**: Полностью удаляет группу из базы данных вместе с её привязками к сегментам
**Входные параметры**: 
- `chat_id` (int) - ID чата/группы в Telegram
**Что делает**: Удаляет записи из таблиц `list_groups` и `groups`
**Связанные функции**: Используется в веб-приложении и боте для полного удаления групп

### remove_group_from_list(self, chat_id: int, list_id: int)
**Назначение**: Удаляет группу из конкретного сегмента (но не из базы данных)
**Входные параметры**:
- `chat_id` (int) - ID группы
- `list_id` (int) - ID сегмента
**Что делает**: Удаляет связь между группой и сегментом в таблице `list_groups`
**Связанные функции**: Используется в bulk операциях веб-приложения

### assign_group_to_list(self, chat_id: int, list_id: int)
**Назначение**: Добавляет группу в сегмент
**Входные параметры**:
- `chat_id` (int) - ID группы
- `list_id` (int) - ID сегмента
**Что делает**: Создает связь между группой и сегментом в таблице `list_groups`
**Связанные функции**: Используется в bulk операциях веб-приложения

### get_groups_with_lists(self)
**Назначение**: Получает сегмент всех групп с их привязками к сегментам
**Входные параметры**: Нет
**Что делает**: Возвращает группы с названиями сегментов, к которым они привязаны
**Связанные функции**: Используется на главной странице веб-приложения

### create_list(self, name: str)
**Назначение**: Создает новый сегмент
**Входные параметры**:
- `name` (str) - название сегмента
**Что делает**: Добавляет новый сегмент в таблицу `lists`
**Связанные функции**: Используется в веб-форме создания сегментов

### delete_list(self, list_id: int)
**Назначение**: Удаляет сегмент из базы данных
**Входные параметры**:
- `list_id` (int) - ID сегмента
**Что делает**: Удаляет сегмент и все его связи с группами
**Связанные функции**: Используется в веб-приложении для удаления сегментов

## Функции веб-приложения (webapp/app.py)

### authenticate(credentials: HTTPBasicCredentials)
**Назначение**: Проверяет аутентификацию пользователя для доступа к админ-панели
**Входные параметры**:
- `credentials` (HTTPBasicCredentials) - объект с логином и паролем из HTTP Basic Auth
**Что делает**: 
- Сравнивает введенные логин/пароль с настройками из config.py
- Использует безопасное сравнение через `secrets.compare_digest`
- Возвращает HTTP 401 если данные неверны
**Связанные функции**: Используется как dependency во всех защищенных роутах веб-приложения
**Настройки**: Использует `WEBAPP_USERNAME` и `WEBAPP_PASSWORD` из переменных окружения

### delete_group(chat_id: int)
**Назначение**: Веб-роут для удаления отдельной группы
**Входные параметры**:
- `chat_id` (int) - ID группы для удаления
**Что делает**: Вызывает `db.delete_group()` и перенаправляет на главную страницу
**Связанные функции**: Связана с `database.delete_group()`

### bulk_groups(request: Request)
**Назначение**: Обрабатывает массовые операции с группами
**Входные параметры**:
- `request` (Request) - HTTP запрос с формой
**Что делает**: В зависимости от действия (`assign`, `unassign`, `delete`) выполняет операции над выбранными группами
**Связанные функции**: Использует `db.assign_group_to_list()`, `db.remove_group_from_list()`, `db.delete_group()`

### create_list(name: str)
**Назначение**: Веб-роут для создания нового сегмента
**Входные параметры**:
- `name` (str) - название сегмента из формы
**Что делает**: Создает новый сегмент через `db.create_list()`
**Связанные функции**: Связана с `database.create_list()`

### assign_group(chat_id: int, list_id: int)
**Назначение**: Веб-роут для привязки группы к списку
**Входные параметры**:
- `chat_id` (int) - ID группы
- `list_id` (int) - ID сегмента
**Что делает**: Привязывает группу к списку через `db.assign_group_to_list()`
**Связанные функции**: Связана с `database.assign_group_to_list()`

### unassign_group(chat_id: int, list_id: int)
**Назначение**: Веб-роут для отвязки группы от сегмента
**Входные параметры**:
- `chat_id` (int) - ID группы
- `list_id` (int) - ID сегмента
**Что делает**: Отвязывает группу от сегмента через `db.remove_group_from_list()`
**Связанные функции**: Связана с `database.remove_group_from_list()`

### add_admin(self, user_id: int, username: str = None, first_name: str = None, added_by: int = None)
**Назначение**: Добавляет администратора в базу данных
**Входные параметры**:
- `user_id` (int) - Telegram ID пользователя
- `username` (str, optional) - имя пользователя в Telegram
- `first_name` (str, optional) - имя пользователя
- `added_by` (int, optional) - ID администратора, который добавил этого пользователя
**Что делает**: Создает запись в таблице `admins` (или обновляет существующую)
**Связанные функции**: Используется в боте для добавления админов и при миграции из конфига

### remove_admin(self, user_id: int)
**Назначение**: Удаляет администратора из базы данных
**Входные параметры**:
- `user_id` (int) - Telegram ID пользователя
**Что делает**: Удаляет запись из таблицы `admins`
**Связанные функции**: Используется в боте для удаления админов

### is_admin(self, user_id: int) -> bool
**Назначение**: Проверяет, является ли пользователь администратором
**Входные параметры**:
- `user_id` (int) - Telegram ID пользователя
**Что делает**: Ищет пользователя в таблице `admins`
**Связанные функции**: Используется в боте для проверки прав доступа

### get_all_admins(self)
**Назначение**: Получает список всех администраторов
**Входные параметры**: Нет
**Что делает**: Возвращает всех админов с их данными (ID, username, имя, дата добавления)
**Связанные функции**: Используется в боте для отображения списка админов

### migrate_admins_from_config(self, admin_ids: list)
**Назначение**: Переносит админов из конфигурации в базу данных
**Входные параметры**:
- `admin_ids` (list) - список ID админов из переменных окружения
**Что делает**: Добавляет админов из конфига в БД, если их еще там нет
**Связанные функции**: Используется при запуске бота для миграции данных

### index(request: Request)
**Назначение**: Главная страница с фильтрацией групп
**Входные параметры**:
- `request` (Request) - HTTP запрос с параметрами фильтрации
**Что делает**: Отображает группы с возможностью фильтрации по сегментам
**Связанные функции**: Использует `db.get_lists()`, `db.get_groups_with_lists()`

## Функции бота (bot.py)

### cmd_refresh(message: types.Message)
**Назначение**: Команда `/refresh` - принудительно обновляет списки сегментов из базы данных
**Входные параметры**:
- `message` (types.Message) - сообщение от пользователя
**Что делает**: Загружает актуальные сегменты из БД и выводит их количество и названия
**Связанные функции**: Использует `db.get_lists()` для получения свежих данных
### handle_broadcast_button(message: types.Message, state: FSMContext)
**Назначение**: Точка входа в меню рассылок (через кнопку "📢 Рассылка").
**Входные параметры**:
- `message` (types.Message)
- `state` (FSMContext)
**Что делает**: Делегирует отрисовку меню в `show_broadcast_menu()`.
**Связанные функции**: `show_broadcast_menu`, `process_broadcast_menu`, `cmd_broadcast`.

### show_broadcast_menu(message: types.Message, state: FSMContext)
**Назначение**: Рендерит меню рассылок без проверки прав (может вызываться из callback-хендлеров).
**Что делает**: Загружает последние рассылки через `db.get_recent_broadcasts_with_message_count(30)`, строит клавиатуру и переводит в `MenuState.broadcast_menu`.
**Связанные функции**: `handle_broadcast_button`, `process_broadcast_menu`.

### process_broadcast_menu(message: types.Message, state: FSMContext)
**Назначение**: Обрабатывает нажатия в меню рассылок (выбор рассылки или создание новой).
**Входные параметры**: `message`, `state`
**Что делает**: 
- При "➕ Новая рассылка" запускает `cmd_broadcast`.
- При выборе конкретной рассылки показывает экран управления с правильным статусом.
- Если пользователь в этом меню отправляет любое сообщение (текст/медиа), оно воспринимается как начало новой рассылки и обрабатывается через `broadcast_save_message` (без необходимости нажимать кнопку "➕ Новая рассылка").
- **Исправлена логика определения статуса рассылки**: теперь учитывается время публикации для корректного отображения статуса старых рассылок.
**Связанные функции**: `handle_broadcast_button`, `process_broadcast_manage`.

### Логика определения статуса рассылки (исправление от 01.01.2025)
**Назначение**: Правильное определение статуса рассылки с учетом времени
**Что делает**: 
- **🗑 УДАЛЕНА**: рассылка помечена как удалённая (`deleted = 1`)
- **✅ Отправлена**: рассылка успешно отправлена (`sent = 1`)
- **📝 Черновик**: рассылка создана, но время публикации не установлено (`scheduled_at = NULL`)
- **⏳ Запланирована**: время публикации установлено и ещё не наступило (`scheduled_at > current_time`)
- **❌ Просрочена**: время публикации установлено, но уже прошло (`scheduled_at <= current_time`), но рассылка не была отправлена
**Изменения**: Ранее все неотправленные рассылки показывались как "Запланированные", теперь статус корректно отражает реальное состояние с учётом времени.
**Связанные функции**: Используется в `process_broadcast_menu` для отображения информации о рассылке.

### Улучшенное отображение содержимого рассылки (01.01.2025)
**Назначение**: Красивое отображение типа и содержимого рассылки вместо `[non-text]`
**Что делает**:
- **Исправлено сохранение контента**: теперь для медиа-сообщений корректно извлекается текст из `caption`, а не только из `text`
- **Умное определение типа**: функция `format_content_preview()` определяет тип контента и форматирует соответствующий preview
- **Поддерживаемые типы**: text, photo, video, video_note, voice, audio, document, animation, sticker, location, contact
- **Форматы отображения**:
  - Только текст: `«Первые 50 символов текста...»`
  - Медиа с текстом: `Изображение и текст: «Первые 50 символов...»`
  - Медиа без текста: `Видео`, `Изображение`, `Документ` и т.д.
**Изменения**: Ранее показывался неинформативный `[non-text]`, теперь пользователь видит точный тип контента и краткий текст.
**Связанные функции**: 
- `process_list_choice` - исправлено извлечение контента из медиа-сообщений
- `process_broadcast_menu` - улучшено отображение preview в списке рассылок

### Исправление навигации в автоудалении (01.01.2025)
**Назначение**: Корректная обработка кнопки "Назад" в режиме ввода времени автоудаления
**Проблема**: При вводе времени автоудаления кнопка "Назад" не работала - бот пытался парсить "назад" как время
**Решение**:
- **Добавлена проверка команд навигации**: В функции `process_auto_delete_input` добавлена обработка команд "назад", "⬅️ назад", "отмена", "❌", "cancel"
- **Умный возврат**: система определяет, откуда пришел пользователь (создание новой рассылки или управление существующей) и возвращает в соответствующее меню
- **Создана функция `show_broadcast_manage_screen`**: выделена логика отображения экрана управления рассылкой для переиспользования
**Что делает**:
- Если пользователь в режиме управления существующей рассылкой - возвращает к экрану управления этой рассылкой
- Если пользователь создавал новую рассылку - возвращает в меню рассылок
- При потере данных - возвращает в главное меню
**Связанные функции**: `process_auto_delete_input`, `show_broadcast_manage_screen`, `process_broadcast_menu`

### show_broadcast_manage_screen(message: types.Message, state: FSMContext, broadcast_id: int)
**Назначение**: Универсальная функция для отображения экрана управления конкретной рассылкой
**Входные параметры**:
- `message` (types.Message) - сообщение пользователя 
- `state` (FSMContext) - контекст состояния FSM
- `broadcast_id` (int) - ID рассылки для отображения
**Что делает**:
- Загружает данные рассылки из БД (контент, статус, время, сегмент)
- Форматирует красивый preview содержимого с определением типа
- Определяет корректный статус с учётом времени
- Строит клавиатуру с кнопками управления в зависимости от статуса
- Переводит в состояние `MenuState.broadcast_manage_show`
**Изменения (01.01.2025)**: Выделена из `process_broadcast_menu` для переиспользования в навигации
**Связанные функции**: `process_broadcast_menu`, `process_auto_delete_input` (для возврата назад)

### auto_delete_skip(callback: types.CallbackQuery, state: FSMContext)
**Назначение**: Завершает создание рассылки без автоудаления после подтверждения времени публикации.
**Что делает (обновлено)**: После сообщения об успешном планировании очищает состояние и сразу возвращает пользователя в меню рассылок через `handle_broadcast_button`, чтобы новая рассылка появилась в списке и была доступна кнопка "➕ Новая рассылка".
**Связанные функции**: `confirm_schedule_callback`, `handle_broadcast_button`.

### auto_delete_confirm(callback: types.CallbackQuery, state: FSMContext)
**Назначение**: Подтверждает время автоудаления для рассылки.
**Что делает (обновлено)**: Сохраняет автоудаление, отправляет или планирует рассылку, затем очищает состояние и возвращает в меню рассылок через `handle_broadcast_button`, чтобы можно было сразу создать новую.
**Связанные функции**: `process_auto_delete_input`, `handle_broadcast_button`.


### is_admin(user_id: int) -> bool (асинхронная)
**Назначение**: Проверяет права администратора пользователя в базе данных
**Входные параметры**:
- `user_id` (int) - Telegram ID пользователя
**Что делает**: Использует `db.is_admin()` для проверки прав в БД
**Связанные функции**: Используется в декораторе `admin_required` и проверках доступа

### handle_settings_button(message: types.Message, state: FSMContext)
**Назначение**: Обработчик кнопки "⚙️ Настройки" - главное меню настроек бота
**Входные параметры**:
- `message` (types.Message) - сообщение пользователя
- `state` (FSMContext) - контекст состояния FSM
**Что делает**: Отображает меню с разделами: управление админами, справка
**Связанные функции**: Переводит в состояние `MenuState.settings_menu`

### process_settings_menu(message: types.Message, state: FSMContext)
**Назначение**: Обработчик выбора в меню настроек
**Входные параметры**:
- `message` (types.Message) - выбор пользователя
- `state` (FSMContext) - контекст состояния
**Что делает**: Обрабатывает выбор раздела настроек (админы/справка)
**Связанные функции**: Переходит к `process_admin_management` или вызывает `cmd_help`

### process_admin_management(message: types.Message, state: FSMContext)
**Назначение**: Главное меню управления администраторами
**Входные параметры**:
- `message` (types.Message) - действие пользователя
- `state` (FSMContext) - контекст состояния
**Что делает**: Показывает список админов и действия (добавить/удалить)
**Связанные функции**: Использует `db.get_all_admins()`, переходы к добавлению/удалению

### handle_user_shared(message: types.Message, state: FSMContext)
**Назначение**: Обработчик выбора пользователя для назначения администратором
**Входные параметры**:
- `message` (types.Message) - сообщение с shared пользователем
- `state` (FSMContext) - контекст состояния
**Что делает**: Добавляет выбранного пользователя в админы через `db.add_admin()`
**Связанные функции**: Работает с `KeyboardButtonRequestUser`, использует `db.add_admin()`

### process_admin_delete_select(message: types.Message, state: FSMContext)
**Назначение**: Обработчик выбора админа для удаления
**Входные параметры**:
- `message` (types.Message) - выбранный для удаления админ
- `state` (FSMContext) - контекст состояния  
**Что делает**: Показывает подтверждение удаления выбранного админа
**Связанные функции**: Переходит к `process_admin_delete_confirm`

### process_admin_delete_confirm(message: types.Message, state: FSMContext)
**Назначение**: Подтверждение удаления администратора
**Входные параметры**:
- `message` (types.Message) - подтверждение пользователя
- `state` (FSMContext) - контекст состояния
**Что делает**: Окончательно удаляет админа через `db.remove_admin()`
**Связанные функции**: Использует `db.remove_admin()` для удаления

## JavaScript функции (webapp/templates/index.html)

### toggleAll(source)
**Назначение**: Выбирает/снимает выбор со всех чекбоксов групп
**Входные параметры**:
- `source` (Element) - чекбокс "Выбрать все"
**Что делает**: Синхронизирует состояние всех чекбоксов с главным
**Связанные функции**: Используется с bulk операциями

### confirmBulkDelete()
**Назначение**: Показывает подтверждение перед массовым удалением групп
**Входные параметры**: Нет (читает выбранные чекбоксы)
**Что делает**: Отображает сегмент групп для удаления и запрашивает подтверждение
**Связанные функции**: Используется с кнопкой массового удаления

### bulkForm submit handler
**Назначение**: Проверяет корректность формы перед отправкой
**Входные параметры**: Event объект
**Что делает**: Проверяет выбор сегмента для операций assign/unassign, убирает required для delete
**Связанные функции**: Работает с функцией `bulk_groups` на сервере

## Основные связи между функциями

1. **Удаление групп**: `delete_group` (веб) → `database.delete_group` → обновление БД
2. **Массовые операции**: `bulk_groups` (веб) → различные методы database в зависимости от действия
3. **Фильтрация**: `index` (веб) → `database.get_groups_with_lists` → отображение
4. **UI взаимодействие**: JavaScript функции → веб-роуты → database методы
5. **Управление админами**: `handle_settings_button` → `process_admin_management` → `db.add_admin`/`db.remove_admin`
6. **Проверка прав**: `admin_required` → `is_admin` → `db.is_admin` → БД
7. **Миграция админов**: запуск бота → `migrate_admins_from_config` → `db.add_admin`

## Состояния FSM для управления админами

### MenuState.settings_menu
**Назначение**: Главное меню настроек
**Переходы**: 
- К `admin_management` при выборе управления админами
- К главному меню при нажатии "Назад"

### MenuState.admin_management  
**Назначение**: Меню управления администраторами
**Переходы**:
- К `admin_add_wait_user` при добавлении админа
- К `admin_delete_select` при удалении админа
- К `settings_menu` при возврате назад

### MenuState.admin_add_wait_user
**Назначение**: Ожидание выбора пользователя для добавления в админы
**Обработчики**: `handle_user_shared` для обработки shared пользователя
**Переходы**: К главному меню после добавления или отмены

### MenuState.admin_delete_select
**Назначение**: Выбор администратора для удаления
**Переходы**: К `admin_delete_confirm` после выбора админа

### MenuState.admin_delete_confirm
**Назначение**: Подтверждение удаления администратора
**Переходы**: К главному меню после удаления или отмены

## Система управления админами

### Таблица admins в БД
```sql
CREATE TABLE admins (
    user_id INTEGER PRIMARY KEY,           -- Telegram ID пользователя
    username TEXT,                         -- Username в Telegram  
    first_name TEXT,                       -- Имя пользователя
    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,  -- Дата добавления
    added_by INTEGER                       -- ID админа, который добавил
);
```

### Миграция из конфига
При запуске бота админы из переменной окружения `ADMIN_IDS` автоматически переносятся в базу данных через `migrate_admins_from_config()`. Это обеспечивает совместимость со старой системой.

### Безопасность
- Нельзя удалить последнего администратора
- Админ не может удалить самого себя  
- Проверка прав осуществляется через БД, а не переменные окружения
- Все операции логируются с указанием добавившего админа 

## Утилиты управления проектом

### start_webapp.py
**Назначение**: Скрипт для запуска веб-приложения административной панели
**Входные параметры**: Нет (настройки читаются из config.py)
**Что делает**:
- Проверяет наличие директории webapp
- Выводит информацию о запуске
- Запускает webapp/app.py через subprocess
- Обрабатывает ошибки и Ctrl+C
**Связанные функции**: Используется в Makefile команде `make start-webapp`

### Makefile
**Назначение**: Автоматизация управления ботом и веб-приложением
**Основные команды**:
- `make start-bot` - запуск бота в фоне через nohup
- `make stop-bot` - остановка бота через pkill (с проверкой процессов)
- `make start-webapp` - запуск веб-панели через start_webapp.py
- `make stop-webapp` - остановка веб-панели (включая uvicorn процессы и принудительное освобождение порта 8000)
- `make force-stop` - принудительная остановка процессов проекта (не все Python процессы)
- `make kill-safe` - безопасная остановка только bot.py и app.py с мягким завершением
- `make cleanup-pids` - очистка устаревших PID-файлов (bot.pid, webapp.pid)
- `make status` - проверка статуса процессов через PID-файлы
- `make logs` - просмотр логов
- `make create-venv` - создание виртуального окружения
- `make setup` - первичная настройка проекта (включает создание venv)
- `make start-all` - запуск бота и веб-панели
- `make stop-all` - остановка всех процессов

**Исправления ошибок**:
- Команда `stop-webapp` теперь корректно останавливает uvicorn процессы
- Добавлена принудительная очистка порта 8000 при ошибке "Address already in use"
- **Система PID-файлов**: команды управления ботом (start-bot, stop-bot, status) теперь используют файлы bot.pid и webapp.pid для точного отслеживания процессов
- **Устранение ложных срабатываний**: команды больше НЕ видят "мёртвые" или зависшие процессы, только активные
- **Безопасная остановка**: использование `kill -0` для проверки существования процесса перед остановкой
- **Фильтрация по директории**: все команды (status, start-bot, stop-bot, stop-webapp, kill-teleblast) теперь работают только с процессами, запущенными из `/home/teleblast` (переменная PROJECT_DIR)
- Команды больше НЕ видят процессы из Docker контейнеров других ботов
- Команда `status` показывает только локальные процессы TeleBlast
- Команда `force-stop` избирательно останавливает только процессы проекта, не все Python процессы
- Команда `kill-safe` использует мягкое завершение (SIGTERM) перед принудительным (SIGKILL)
- **Безопасная остановка процессов**: добавлены проверки валидности PID (не пустой, больше 0) перед вызовом kill
- Все команды остановки используют двухэтапный процесс: SIGTERM (мягкое завершение), затем SIGKILL (принудительное)
- Добавлена поддержка создания виртуального окружения
- Исправлена проблема с множественными экземплярами бота (Telegram Flood Control)
- **Полностью устранена ошибка "Terminated"** при выполнении команд остановки

**Проблема Telegram Flood Control**:
Множественные экземпляры бота вызывают ошибки "Flood control exceeded" в Telegram API.
Это происходит когда несколько ботов одновременно делают запросы getUpdates.
Решение: обязательно останавливать все экземпляры перед новым запуском через `make kill-teleblast`.

**Система PID-файлов**:
Команды управления ботом используют файлы `bot.pid` и `webapp.pid` для точного отслеживания процессов:
- При запуске бота PID сохраняется в файл
- При проверке статуса читается PID из файла и проверяется активность процесса (`kill -0`)
- При остановке используется точный PID из файла, а не поиск по командной строке
- Автоматическая очистка устаревших PID-файлов через `make cleanup-pids`

**Фильтрация процессов по директории**:
Все команды Makefile теперь используют проверку рабочей директории процесса (`/proc/PID/cwd`) для фильтрации только процессов TeleBlast, запущенных из директории проекта. Это исключает ложные срабатывания на другие боты.

**Связанные файлы**: 
- Использует start_webapp.py для запуска веб-приложения
- Создает bot.log для логов бота
- Работает с .env файлом через команду setup
- Создает и управляет виртуальным окружением venv/

## Утилита очистки базы данных

### clear_database.py
**Назначение**: Скрипт для полной очистки базы данных TeleBlast после тестирования
**Входные параметры**: Нет (интерактивное подтверждение)
**Что делает**:
- Показывает текущую статистику базы данных
- Запрашивает двойное подтверждение пользователя
- Очищает все таблицы в правильном порядке (с учетом внешних ключей)
- Выводит результат операции
**Связанные функции**: Использует класс Database для подключения к БД

**Порядок очистки таблиц**:
1. `broadcast_messages` - сообщения рассылок
2. `broadcasts` - рассылки
3. `list_groups` - связи групп и сегментов
4. `groups` - группы
5. `lists` - сегменты

**Использование**:
```bash
python clear_database.py
```

**Безопасность**:
- Требует подтверждения "да/нет"
- Требует ввода слова "УДАЛИТЬ" заглавными буквами
- Показывает статистику до очистки
- Проверяет результат после очистки 